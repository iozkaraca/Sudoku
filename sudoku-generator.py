'''
Sudoku generator app. 

User inputs:
level: (str) how hard sudokus you want to be

Steps:

Step 1: Define a random bijection f over the set {1,2,..,9}.
Step 2: Define a sudoku matrix from f
Step 3: Shuffle the matrix f in order to add more randomness by applying the following 10_000 times.
        i. Row exchange
        ii. Taking transpose


Details of the above steps, and generating sudokus are given by the following theorems.

Theorem 1: Suppose x is an numpy arrow of length 9, and contains all integers 
between 1 and 9 (including 1 and 9). Then the following matrix A defines a sudoku.
A = np.array([np.roll(x,i) for i in [0,-3,-6,-1,-4,-7,-2,-5,-8]])

Proof: Clear by the fact that each row and (columns) is a shift of initial row (column),
and {0,-3,-6,-1,-4,-7,-2,-5,-8} is a set of length 9.

Theorem 2: Suppose A=[a_ij] is a 9x9 matrix defining a sudoku game, and f is a bijection on the set
{1,2,..,9}. Then B=[f(a_ij)] is a well-defined sudoku.

Proof: Clear by the fact that f is a bijection.

Theorem 3: Suppose A=[a_ij] is a 9x9 Matrix defining a sudoku game. If B is a matrix generated by
swaping two (distinct) rows i,j of A so that 0<=i,j<=9 and floor(i/3) = floor(j/3)
(that is, i and j are on the same 3x3 grid), then A also defines a sudoku game.

Proof: Clear.
'''

import PySimpleGUI as sg
from turtle import *
import numpy as np
import random
import itertools


# Collection of all bijective permutations over the set {1,2,...,9}
S = list(itertools.permutations(np.arange(1,10))) # List of all bijections


def bijection(S=list(itertools.permutations(np.arange(1,10)))):
    # Defines a random bijection on the set {1,2,..,9}
    t = random.randint(0,362879) # A random bijection seed for S
    return np.array(S[t])


def swap(A,i,j):
    # Swap i-th and j-th rows of a given sudoku matrix A, 
    A[[i,j]] = A[[j, i]]
    return A


def sudoku_matrix():
    # Generates random sudoku matrix.
    
    # A random row.
    row = bijection()
    
    # A Sudoku Matrix from the generated random row.
    A = np.array([np.roll(row,i) for i in [0,-3,-6,-1,-4,-7,-2,-5,-8]])
    
    # Shuffle A 10_000 times using row-exchange and transpose operations.
    for shuffle in range(2):
        A = A.T
        i,j = random.sample(list(range(3)),2) # two random integers to apply row-swap
        k = random.randint(0,2) # indicates which 3x3 grid is going to be used for row-swap
        A = swap(A,i+3*k,j+3*k) # apply row-swap.
    return A


def drawtheboard(ss):
    # This function draws the board. Inputs are:
    # ss : Turtle pointer
    
    ss.pen(pencolor="black", pensize=1)
    for i in range(10):
        ss.penup()
        ss.setpos(-250, -250 + 50*i)
        ss.pendown()
        ss.forward(450)
    ss.left(90)
    for j in range(10):
        ss.penup()
        ss.setpos(-250 + 50*j, -250)
        ss.pendown()
        ss.forward(450)
    ss.right(90)
    ss.pen(pencolor="black", pensize=5)
    for i in range(4):
        ss.penup()
        ss.setpos(-250, -250 + 150*i)
        ss.pendown()
        ss.forward(450)
    ss.left(90)
    for j in range(0,4):
        ss.penup()
        ss.setpos(-250 + 150*j, -250)
        ss.pendown()
        ss.forward(450)


def drawthequestion(ss, arr, level='easy'):
    # Draws the sudoku puzzle. Inputs are:
    # ss : Turtle pointer
    # arr (np.array): sudoku matrix
    # level (str): allowed inputs are 'easy', 'moderate' and 'hard'
    
    if level == 'easy':
        level_index = 3
    elif level == 'moderate':
        level_index = 2
    elif level == 'hard':
        level_index = 1
    else:
        print('Wrong input..')
    
    # draw the board
    drawtheboard(ss)
    
    for i in range(9):
        x = random.sample(range(9), level_index)
        for j in range(level_index):
            ss.penup()
            ss.setpos(-250 + 50*x[j] + 25, 400 - 250 + 15 - 50 * i)
            ss.pendown()
            ss.write(arr[i][x[j]], move=False, align="center", font=("Arial", 15, "bold"))


def drawthesolution(ss, arr):
    # Outputs the full solution. Inputs are:
    # ss : Turtle pointer
    # arr (np.array): sudoku matrix
    
    # draw the board.
    drawtheboard(ss)

    # The solution:
    for i,j in itertools.product(range(9),range(9)):
        ss.penup()
        ss.setpos(-250 + 50*j + 25, 400 - 250 + 15 - 50 * i)
        ss.pendown()
        ss.write(arr[i][j], move=False, align="center", font=("Arial", 15, "bold"))


def resettheboard(ss):
    # Resets the board. Inputs are:
    # ss : Turtle pointer
    
    ss.clear()
    ss.right(90)


sg.theme('GrayGrayGray')   # Add a touch of color
main_screen = [[sg.Text('Level'), sg.InputText()], [sg.Button('Generate'), sg.Button('Solution'), sg.Button('Exit')]]


if __name__ == "__main__":
    # Create the Window
    window = sg.Window('Sudoku Generator', main_screen)
    matrix_list = []
    canvas = Screen()
    ss = Turtle()
    ss.hideturtle()
    ss.speed(0)
    ss._tracer(False)
    input_index=0
    while True:
        arr = sudoku_matrix()
        matrix_list.append(arr)
        button_input, written_input = window.read()
        if button_input == 'Exit' or button_input == sg.WIN_CLOSED:
            break
        elif button_input == 'Generate': 
            if input_index > 0:
                resettheboard(ss)
            drawthequestion(ss,matrix_list[input_index],written_input[0])
        elif button_input == 'Solution':
            if input_index == 0:
                break
            elif input_index > 0:
                resettheboard(ss)
            drawthesolution(ss,matrix_list[input_index-1])
        input_index += 1
    
